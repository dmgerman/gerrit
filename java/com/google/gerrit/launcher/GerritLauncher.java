begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Copyright (C) 2009 The Android Open Source Project
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Licensed under the Apache License, Version 2.0 (the "License");
end_comment

begin_comment
comment|// you may not use this file except in compliance with the License.
end_comment

begin_comment
comment|// You may obtain a copy of the License at
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// http://www.apache.org/licenses/LICENSE-2.0
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Unless required by applicable law or agreed to in writing, software
end_comment

begin_comment
comment|// distributed under the License is distributed on an "AS IS" BASIS,
end_comment

begin_comment
comment|// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
end_comment

begin_comment
comment|// See the License for the specific language governing permissions and
end_comment

begin_comment
comment|// limitations under the License.
end_comment

begin_package
DECL|package|com.google.gerrit.launcher
package|package
name|com
operator|.
name|google
operator|.
name|gerrit
operator|.
name|launcher
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
operator|.
name|UTF_8
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|DAYS
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
operator|.
name|MILLISECONDS
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|JarURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLClassLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|FileSystems
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|CodeSource
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|Attributes
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|JarFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|Manifest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipEntry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipFile
import|;
end_import

begin_comment
comment|/** Main class for a JAR file to run code from "WEB-INF/lib". */
end_comment

begin_class
DECL|class|GerritLauncher
specifier|public
specifier|final
class|class
name|GerritLauncher
block|{
DECL|field|PKG
specifier|private
specifier|static
specifier|final
name|String
name|PKG
init|=
literal|"com.google.gerrit.pgm"
decl_stmt|;
DECL|field|NOT_ARCHIVED
specifier|public
specifier|static
specifier|final
name|String
name|NOT_ARCHIVED
init|=
literal|"NOT_ARCHIVED"
decl_stmt|;
DECL|field|daemonClassLoader
specifier|private
specifier|static
name|ClassLoader
name|daemonClassLoader
decl_stmt|;
DECL|method|main (String[] argv)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|argv
parameter_list|)
throws|throws
name|Exception
block|{
name|System
operator|.
name|exit
argument_list|(
name|mainImpl
argument_list|(
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Invokes a proram.    *    *<p>Creates a new classloader to load and run the program class. To reuse a classloader across    * calls (e.g. from tests), use {@link #invokeProgram(ClassLoader, String[])}.    *    * @param argv arguments, as would be passed to {@code gerrit.war}. The first argument is the    *     program name.    * @return program return code.    * @throws Exception if any error occurs.    */
DECL|method|mainImpl (String[] argv)
specifier|public
specifier|static
name|int
name|mainImpl
parameter_list|(
name|String
index|[]
name|argv
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|argv
operator|.
name|length
operator|==
literal|0
operator|||
literal|"-h"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|||
literal|"--help"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|File
name|me
decl_stmt|;
try|try
block|{
name|me
operator|=
name|getDistributionArchive
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|me
operator|=
literal|null
expr_stmt|;
block|}
name|String
name|jar
init|=
name|me
operator|!=
literal|null
condition|?
name|me
operator|.
name|getName
argument_list|()
else|:
literal|"gerrit.war"
decl_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Gerrit Code Review "
operator|+
name|getVersion
argument_list|(
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"usage: java -jar "
operator|+
name|jar
operator|+
literal|" command [ARG ...]"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"The most commonly used commands are:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  init            Initialize a Gerrit installation"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  reindex         Rebuild the secondary index"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  daemon          Run the Gerrit network daemons"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  gsql            Run the interactive query console"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  version         Display the build version number"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  passwd          Set or change password in secure.config"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  ls              List files available for cat"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"  cat FILE        Display a file from the archive"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|// Special cases, a few global options actually are programs.
comment|//
if|if
condition|(
literal|"-v"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|||
literal|"--version"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
literal|"version"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-p"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|||
literal|"--cat"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
literal|"cat"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-l"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|||
literal|"--ls"
operator|.
name|equals
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
literal|"ls"
expr_stmt|;
block|}
comment|// Run the application class
comment|//
specifier|final
name|ClassLoader
name|cl
init|=
name|libClassLoader
argument_list|(
name|isProlog
argument_list|(
name|programClassName
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setContextClassLoader
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
name|invokeProgram
argument_list|(
name|cl
argument_list|,
name|argv
argument_list|)
return|;
block|}
DECL|method|daemonStart (String[] argv)
specifier|public
specifier|static
name|void
name|daemonStart
parameter_list|(
name|String
index|[]
name|argv
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|daemonClassLoader
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"daemonStart can be called only once per JVM instance"
argument_list|)
throw|;
block|}
specifier|final
name|ClassLoader
name|cl
init|=
name|libClassLoader
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setContextClassLoader
argument_list|(
name|cl
argument_list|)
expr_stmt|;
name|daemonClassLoader
operator|=
name|cl
expr_stmt|;
name|String
index|[]
name|daemonArgv
init|=
operator|new
name|String
index|[
name|argv
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|daemonArgv
index|[
literal|0
index|]
operator|=
literal|"daemon"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argv
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|daemonArgv
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|int
name|res
init|=
name|invokeProgram
argument_list|(
name|cl
argument_list|,
name|daemonArgv
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Unexpected return value: "
operator|+
name|res
argument_list|)
throw|;
block|}
block|}
DECL|method|daemonStop (String[] argv)
specifier|public
specifier|static
name|void
name|daemonStop
parameter_list|(
name|String
index|[]
name|argv
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|daemonClassLoader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"daemonStop can be called only after call to daemonStop"
argument_list|)
throw|;
block|}
name|String
index|[]
name|daemonArgv
init|=
operator|new
name|String
index|[
name|argv
operator|.
name|length
operator|+
literal|2
index|]
decl_stmt|;
name|daemonArgv
index|[
literal|0
index|]
operator|=
literal|"daemon"
expr_stmt|;
name|daemonArgv
index|[
literal|1
index|]
operator|=
literal|"--stop-only"
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argv
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|daemonArgv
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|int
name|res
init|=
name|invokeProgram
argument_list|(
name|daemonClassLoader
argument_list|,
name|daemonArgv
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Unexpected return value: "
operator|+
name|res
argument_list|)
throw|;
block|}
block|}
DECL|method|isProlog (String cn)
specifier|private
specifier|static
name|boolean
name|isProlog
parameter_list|(
name|String
name|cn
parameter_list|)
block|{
return|return
literal|"PrologShell"
operator|.
name|equals
argument_list|(
name|cn
argument_list|)
operator|||
literal|"Rulec"
operator|.
name|equals
argument_list|(
name|cn
argument_list|)
return|;
block|}
DECL|method|getVersion (File me)
specifier|private
specifier|static
name|String
name|getVersion
parameter_list|(
name|File
name|me
parameter_list|)
block|{
if|if
condition|(
name|me
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
try|try
init|(
name|JarFile
name|jar
init|=
operator|new
name|JarFile
argument_list|(
name|me
argument_list|)
init|)
block|{
name|Manifest
name|mf
init|=
name|jar
operator|.
name|getManifest
argument_list|()
decl_stmt|;
name|Attributes
name|att
init|=
name|mf
operator|.
name|getMainAttributes
argument_list|()
decl_stmt|;
name|String
name|val
init|=
name|att
operator|.
name|getValue
argument_list|(
name|Attributes
operator|.
name|Name
operator|.
name|IMPLEMENTATION_VERSION
argument_list|)
decl_stmt|;
return|return
name|val
operator|!=
literal|null
condition|?
name|val
else|:
literal|""
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|""
return|;
block|}
block|}
comment|/**    * Invokes a proram in the provided {@code ClassLoader}.    *    * @param loader classloader to load program class from.    * @param origArgv arguments, as would be passed to {@code gerrit.war}. The first argument is the    *     program name.    * @return program return code.    * @throws Exception if any error occurs.    */
DECL|method|invokeProgram (ClassLoader loader, String[] origArgv)
specifier|public
specifier|static
name|int
name|invokeProgram
parameter_list|(
name|ClassLoader
name|loader
parameter_list|,
name|String
index|[]
name|origArgv
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|name
init|=
name|origArgv
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|String
index|[]
name|argv
init|=
operator|new
name|String
index|[
name|origArgv
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|origArgv
argument_list|,
literal|1
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|,
name|argv
operator|.
name|length
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
decl_stmt|;
try|try
block|{
try|try
block|{
name|String
name|cn
init|=
name|programClassName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|PKG
operator|+
literal|"."
operator|+
name|cn
argument_list|,
literal|true
argument_list|,
name|loader
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|name
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|PKG
operator|+
literal|"."
operator|+
name|name
argument_list|,
literal|true
argument_list|,
name|loader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|cnfe
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"fatal: unknown command "
operator|+
name|name
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"      (no "
operator|+
name|PKG
operator|+
literal|"."
operator|+
name|name
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|final
name|Method
name|main
decl_stmt|;
try|try
block|{
name|main
operator|=
name|clazz
operator|.
name|getMethod
argument_list|(
literal|"main"
argument_list|,
name|argv
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
decl||
name|NoSuchMethodException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"fatal: unknown command "
operator|+
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|final
name|Object
name|res
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|main
operator|.
name|getModifiers
argument_list|()
operator|&
name|Modifier
operator|.
name|STATIC
operator|)
operator|==
name|Modifier
operator|.
name|STATIC
condition|)
block|{
name|res
operator|=
name|main
operator|.
name|invoke
argument_list|(
literal|null
argument_list|,
operator|new
name|Object
index|[]
block|{
name|argv
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|main
operator|.
name|invoke
argument_list|(
name|clazz
operator|.
name|getConstructor
argument_list|(
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{}
block|)
operator|.
name|newInstance
argument_list|()
operator|,
operator|new
name|Object
index|[]
block|{
name|argv
block|}
block|)
empty_stmt|;
block|}
block|}
end_class

begin_catch
catch|catch
parameter_list|(
name|InvocationTargetException
name|ite
parameter_list|)
block|{
if|if
condition|(
name|ite
operator|.
name|getCause
argument_list|()
operator|instanceof
name|Exception
condition|)
block|{
throw|throw
operator|(
name|Exception
operator|)
name|ite
operator|.
name|getCause
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|ite
operator|.
name|getCause
argument_list|()
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|ite
operator|.
name|getCause
argument_list|()
throw|;
block|}
else|else
block|{
throw|throw
name|ite
throw|;
block|}
block|}
end_catch

begin_if
if|if
condition|(
name|res
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|res
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
end_if

begin_return
return|return
literal|0
return|;
end_return

begin_function
unit|}    private
DECL|method|programClassName (String cn)
specifier|static
name|String
name|programClassName
parameter_list|(
name|String
name|cn
parameter_list|)
block|{
if|if
condition|(
name|cn
operator|.
name|equals
argument_list|(
name|cn
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|cn
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|cn
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cn
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'-'
operator|&&
name|i
operator|+
literal|1
operator|<
name|cn
operator|.
name|length
argument_list|()
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|cn
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
name|cn
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
return|return
name|cn
return|;
block|}
end_function

begin_function
DECL|method|libClassLoader (boolean prologCompiler)
specifier|private
specifier|static
name|ClassLoader
name|libClassLoader
parameter_list|(
name|boolean
name|prologCompiler
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|path
decl_stmt|;
try|try
block|{
name|path
operator|=
name|getDistributionArchive
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
if|if
condition|(
name|NOT_ARCHIVED
operator|.
name|equals
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|useDevClasspath
argument_list|()
return|;
block|}
throw|throw
name|e
throw|;
block|}
specifier|final
name|SortedMap
argument_list|<
name|String
argument_list|,
name|URL
argument_list|>
name|jars
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|ZipFile
name|zf
init|=
operator|new
name|ZipFile
argument_list|(
name|path
argument_list|)
init|)
block|{
specifier|final
name|Enumeration
argument_list|<
name|?
extends|extends
name|ZipEntry
argument_list|>
name|e
init|=
name|zf
operator|.
name|entries
argument_list|()
decl_stmt|;
while|while
condition|(
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
specifier|final
name|ZipEntry
name|ze
init|=
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|ze
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|String
name|name
init|=
name|ze
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"WEB-INF/lib/"
argument_list|)
condition|)
block|{
name|extractJar
argument_list|(
name|zf
argument_list|,
name|ze
argument_list|,
name|jars
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"WEB-INF/pgm-lib/"
argument_list|)
condition|)
block|{
comment|// Some Prolog tools are restricted.
if|if
condition|(
name|prologCompiler
operator|||
operator|!
name|name
operator|.
name|startsWith
argument_list|(
literal|"WEB-INF/pgm-lib/prolog-"
argument_list|)
condition|)
block|{
name|extractJar
argument_list|(
name|zf
argument_list|,
name|ze
argument_list|,
name|jars
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot obtain libraries from "
operator|+
name|path
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|jars
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|GerritLauncher
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
return|;
block|}
comment|// The extension API needs to be its own ClassLoader, along
comment|// with a few of its dependencies. Try to construct this first.
name|List
argument_list|<
name|URL
argument_list|>
name|extapi
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"gerrit-extension-api-"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"guice-"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"javax.inject-1.jar"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"aopalliance-1.0.jar"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"guice-servlet-"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|jars
argument_list|,
literal|"tomcat-servlet-api-"
argument_list|,
name|extapi
argument_list|)
expr_stmt|;
name|ClassLoader
name|parent
init|=
name|ClassLoader
operator|.
name|getSystemClassLoader
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|extapi
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|parent
operator|=
name|URLClassLoader
operator|.
name|newInstance
argument_list|(
name|extapi
operator|.
name|toArray
argument_list|(
operator|new
name|URL
index|[
name|extapi
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
return|return
name|URLClassLoader
operator|.
name|newInstance
argument_list|(
name|jars
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|URL
index|[
name|jars
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|parent
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|extractJar (ZipFile zf, ZipEntry ze, SortedMap<String, URL> jars)
specifier|private
specifier|static
name|void
name|extractJar
parameter_list|(
name|ZipFile
name|zf
parameter_list|,
name|ZipEntry
name|ze
parameter_list|,
name|SortedMap
argument_list|<
name|String
argument_list|,
name|URL
argument_list|>
name|jars
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|tmp
init|=
name|createTempFile
argument_list|(
name|safeName
argument_list|(
name|ze
argument_list|)
argument_list|,
literal|".jar"
argument_list|)
decl_stmt|;
try|try
init|(
name|OutputStream
name|out
init|=
name|Files
operator|.
name|newOutputStream
argument_list|(
name|tmp
operator|.
name|toPath
argument_list|()
argument_list|)
init|;
name|InputStream
name|in
operator|=
name|zf
operator|.
name|getInputStream
argument_list|(
name|ze
argument_list|)
init|)
block|{
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|name
init|=
name|ze
operator|.
name|getName
argument_list|()
decl_stmt|;
name|jars
operator|.
name|put
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|name
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|tmp
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|move (SortedMap<String, URL> jars, String prefix, List<URL> extapi)
specifier|private
specifier|static
name|void
name|move
parameter_list|(
name|SortedMap
argument_list|<
name|String
argument_list|,
name|URL
argument_list|>
name|jars
parameter_list|,
name|String
name|prefix
parameter_list|,
name|List
argument_list|<
name|URL
argument_list|>
name|extapi
parameter_list|)
block|{
name|SortedMap
argument_list|<
name|String
argument_list|,
name|URL
argument_list|>
name|matches
init|=
name|jars
operator|.
name|tailMap
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matches
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|first
init|=
name|matches
operator|.
name|firstKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|extapi
operator|.
name|add
argument_list|(
name|jars
operator|.
name|remove
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
DECL|method|safeName (ZipEntry ze)
specifier|private
specifier|static
name|String
name|safeName
parameter_list|(
name|ZipEntry
name|ze
parameter_list|)
block|{
comment|// Try to derive the name of the temporary file so it
comment|// doesn't completely suck. Best if we can make it
comment|// match the name it was in the archive.
comment|//
name|String
name|name
init|=
name|ze
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|contains
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|.
name|contains
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|name
operator|=
literal|"code"
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_decl_stmt
DECL|field|myArchive
specifier|private
specifier|static
specifier|volatile
name|File
name|myArchive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|myHome
specifier|private
specifier|static
specifier|volatile
name|File
name|myHome
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|zipFileSystems
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Path
argument_list|,
name|FileSystem
argument_list|>
name|zipFileSystems
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**    * Locate the JAR/WAR file we were launched from.    *    * @return local path of the Gerrit WAR file.    * @throws FileNotFoundException if the code cannot guess the location.    */
end_comment

begin_function
DECL|method|getDistributionArchive ()
specifier|public
specifier|static
name|File
name|getDistributionArchive
parameter_list|()
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
name|File
name|result
init|=
name|myArchive
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|GerritLauncher
operator|.
name|class
init|)
block|{
name|result
operator|=
name|myArchive
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
name|result
operator|=
name|locateMyArchive
argument_list|()
expr_stmt|;
name|myArchive
operator|=
name|result
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
DECL|method|getZipFileSystem (Path zip)
specifier|public
specifier|static
specifier|synchronized
name|FileSystem
name|getZipFileSystem
parameter_list|(
name|Path
name|zip
parameter_list|)
throws|throws
name|IOException
block|{
comment|// FileSystems canonicalizes the path, so we should too.
name|zip
operator|=
name|zip
operator|.
name|toRealPath
argument_list|()
expr_stmt|;
name|FileSystem
name|zipFs
init|=
name|zipFileSystems
operator|.
name|get
argument_list|(
name|zip
argument_list|)
decl_stmt|;
if|if
condition|(
name|zipFs
operator|==
literal|null
condition|)
block|{
name|zipFs
operator|=
name|newZipFileSystem
argument_list|(
name|zip
argument_list|)
expr_stmt|;
name|zipFileSystems
operator|.
name|put
argument_list|(
name|zip
argument_list|,
name|zipFs
argument_list|)
expr_stmt|;
block|}
return|return
name|zipFs
return|;
block|}
end_function

begin_function
DECL|method|newZipFileSystem (Path zip)
specifier|public
specifier|static
name|FileSystem
name|newZipFileSystem
parameter_list|(
name|Path
name|zip
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|FileSystems
operator|.
name|newFileSystem
argument_list|(
name|URI
operator|.
name|create
argument_list|(
literal|"jar:"
operator|+
name|zip
operator|.
name|toUri
argument_list|()
argument_list|)
argument_list|,
name|Collections
operator|.
expr|<
name|String
argument_list|,
name|String
operator|>
name|emptyMap
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|locateMyArchive ()
specifier|private
specifier|static
name|File
name|locateMyArchive
parameter_list|()
throws|throws
name|FileNotFoundException
block|{
specifier|final
name|ClassLoader
name|myCL
init|=
name|GerritLauncher
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
decl_stmt|;
specifier|final
name|String
name|myName
init|=
name|GerritLauncher
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|".class"
decl_stmt|;
specifier|final
name|URL
name|myClazz
init|=
name|myCL
operator|.
name|getResource
argument_list|(
name|myName
argument_list|)
decl_stmt|;
if|if
condition|(
name|myClazz
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Cannot find JAR: no "
operator|+
name|myName
argument_list|)
throw|;
block|}
comment|// ZipFile may have the path of our JAR hiding within itself.
comment|//
try|try
block|{
name|JarFile
name|jar
init|=
operator|(
operator|(
name|JarURLConnection
operator|)
name|myClazz
operator|.
name|openConnection
argument_list|()
operator|)
operator|.
name|getJarFile
argument_list|()
decl_stmt|;
name|File
name|path
init|=
operator|new
name|File
argument_list|(
name|jar
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return
name|path
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Nope, that didn't work. Try a different method.
comment|//
block|}
comment|// Maybe this is a local class file, running under a debugger?
comment|//
if|if
condition|(
literal|"file"
operator|.
name|equals
argument_list|(
name|myClazz
operator|.
name|getProtocol
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|File
name|path
init|=
operator|new
name|File
argument_list|(
name|myClazz
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|isFile
argument_list|()
operator|&&
name|path
operator|.
name|getParentFile
argument_list|()
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|NOT_ARCHIVED
argument_list|)
throw|;
block|}
block|}
comment|// The CodeSource might be able to give us the source as a stream.
comment|// If so, copy it to a local file so we have random access to it.
comment|//
specifier|final
name|CodeSource
name|src
init|=
name|GerritLauncher
operator|.
name|class
operator|.
name|getProtectionDomain
argument_list|()
operator|.
name|getCodeSource
argument_list|()
decl_stmt|;
if|if
condition|(
name|src
operator|!=
literal|null
condition|)
block|{
try|try
init|(
name|InputStream
name|in
init|=
name|src
operator|.
name|getLocation
argument_list|()
operator|.
name|openStream
argument_list|()
init|)
block|{
specifier|final
name|File
name|tmp
init|=
name|createTempFile
argument_list|(
literal|"gerrit_"
argument_list|,
literal|".zip"
argument_list|)
decl_stmt|;
try|try
init|(
name|OutputStream
name|out
init|=
name|Files
operator|.
name|newOutputStream
argument_list|(
name|tmp
operator|.
name|toPath
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tmp
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Nope, that didn't work.
comment|//
block|}
block|}
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Cannot find local copy of JAR"
argument_list|)
throw|;
block|}
end_function

begin_decl_stmt
DECL|field|temporaryDirectoryFound
specifier|private
specifier|static
name|boolean
name|temporaryDirectoryFound
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|temporaryDirectory
specifier|private
specifier|static
name|File
name|temporaryDirectory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**    * Creates a temporary file within the application's unpack location.    *    *<p>The launcher unpacks the nested JAR files into a temporary directory, allowing the classes    * to be loaded from local disk with standard Java APIs. This method constructs a new temporary    * file in the same directory.    *    *<p>The method first tries to create {@code prefix + suffix} within the directory under the    * assumption that a given {@code prefix + suffix} combination is made at most once per JVM    * execution. If this fails (e.g. the named file already exists) a mangled unique name is used and    * returned instead, with the unique string appearing between the prefix and suffix.    *    *<p>Files created by this method will be automatically deleted by the JVM when it terminates. If    * the returned file is converted into a directory by the caller, the caller must arrange for the    * contents to be deleted before the directory is.    *    *<p>If supported by the underlying operating system, the temporary directory which contains    * these temporary files is accessible only by the user running the JVM.    *    * @param prefix prefix of the file name.    * @param suffix suffix of the file name.    * @return the path of the temporary file. The returned object exists in the filesystem as a file;    *     caller may need to delete and recreate as a directory if a directory was preferred.    * @throws IOException the file could not be created.    */
end_comment

begin_function
DECL|method|createTempFile (String prefix, String suffix)
specifier|public
specifier|static
specifier|synchronized
name|File
name|createTempFile
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|temporaryDirectoryFound
condition|)
block|{
specifier|final
name|File
name|d
init|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"gerrit_"
argument_list|,
literal|"_app"
argument_list|,
name|tmproot
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|delete
argument_list|()
operator|&&
name|d
operator|.
name|mkdir
argument_list|()
condition|)
block|{
comment|// Try to lock the directory down to be accessible by us.
comment|// We first have to remove all permissions, then add back
comment|// only the owner permissions.
comment|//
name|d
operator|.
name|setWritable
argument_list|(
literal|false
argument_list|,
literal|false
comment|/* all */
argument_list|)
expr_stmt|;
name|d
operator|.
name|setReadable
argument_list|(
literal|false
argument_list|,
literal|false
comment|/* all */
argument_list|)
expr_stmt|;
name|d
operator|.
name|setExecutable
argument_list|(
literal|false
argument_list|,
literal|false
comment|/* all */
argument_list|)
expr_stmt|;
name|d
operator|.
name|setWritable
argument_list|(
literal|true
argument_list|,
literal|true
comment|/* owner only */
argument_list|)
expr_stmt|;
name|d
operator|.
name|setReadable
argument_list|(
literal|true
argument_list|,
literal|true
comment|/* owner only */
argument_list|)
expr_stmt|;
name|d
operator|.
name|setExecutable
argument_list|(
literal|true
argument_list|,
literal|true
comment|/* owner only */
argument_list|)
expr_stmt|;
name|d
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
name|temporaryDirectory
operator|=
name|d
expr_stmt|;
block|}
name|temporaryDirectoryFound
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|temporaryDirectory
operator|!=
literal|null
condition|)
block|{
comment|// If we have a private directory and this name has not yet
comment|// been used within the private directory, create it as-is.
comment|//
specifier|final
name|File
name|tmp
init|=
operator|new
name|File
argument_list|(
name|temporaryDirectory
argument_list|,
name|prefix
operator|+
name|suffix
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|createNewFile
argument_list|()
condition|)
block|{
name|tmp
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
return|return
name|tmp
return|;
block|}
block|}
if|if
condition|(
operator|!
name|prefix
operator|.
name|endsWith
argument_list|(
literal|"_"
argument_list|)
condition|)
block|{
name|prefix
operator|+=
literal|"_"
expr_stmt|;
block|}
specifier|final
name|File
name|tmp
init|=
name|File
operator|.
name|createTempFile
argument_list|(
name|prefix
argument_list|,
name|suffix
argument_list|,
name|temporaryDirectory
argument_list|)
decl_stmt|;
name|tmp
operator|.
name|deleteOnExit
argument_list|()
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/**    * Provide path to a working directory    *    * @return local path of the working directory or null if cannot be determined    */
end_comment

begin_function
DECL|method|getHomeDirectory ()
specifier|public
specifier|static
name|File
name|getHomeDirectory
parameter_list|()
block|{
if|if
condition|(
name|myHome
operator|==
literal|null
condition|)
block|{
name|myHome
operator|=
name|locateHomeDirectory
argument_list|()
expr_stmt|;
block|}
return|return
name|myHome
return|;
block|}
end_function

begin_function
DECL|method|tmproot ()
specifier|private
specifier|static
name|File
name|tmproot
parameter_list|()
block|{
name|File
name|tmp
decl_stmt|;
name|String
name|gerritTemp
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"GERRIT_TMP"
argument_list|)
decl_stmt|;
if|if
condition|(
name|gerritTemp
operator|!=
literal|null
operator|&&
name|gerritTemp
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
operator|new
name|File
argument_list|(
name|gerritTemp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
operator|new
name|File
argument_list|(
name|getHomeDirectory
argument_list|()
argument_list|,
literal|"tmp"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmp
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|tmp
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: cannot create "
operator|+
name|tmp
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: using system temporary directory instead"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Try to clean up any stale empty directories. Assume any empty
comment|// directory that is older than 7 days is one of these dead ones
comment|// that we can clean up.
comment|//
specifier|final
name|File
index|[]
name|tmpEntries
init|=
name|tmp
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmpEntries
operator|!=
literal|null
condition|)
block|{
specifier|final
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|long
name|expired
init|=
name|now
operator|-
name|MILLISECONDS
operator|.
name|convert
argument_list|(
literal|7
argument_list|,
name|DAYS
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|tmpEntry
range|:
name|tmpEntries
control|)
block|{
if|if
condition|(
name|tmpEntry
operator|.
name|isDirectory
argument_list|()
operator|&&
name|tmpEntry
operator|.
name|lastModified
argument_list|()
operator|<
name|expired
condition|)
block|{
specifier|final
name|String
index|[]
name|all
init|=
name|tmpEntry
operator|.
name|list
argument_list|()
decl_stmt|;
if|if
condition|(
name|all
operator|==
literal|null
operator|||
name|all
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|tmpEntry
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
try|try
block|{
return|return
name|tmp
operator|.
name|getCanonicalFile
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|tmp
return|;
block|}
block|}
end_function

begin_function
DECL|method|locateHomeDirectory ()
specifier|private
specifier|static
name|File
name|locateHomeDirectory
parameter_list|()
block|{
comment|// Try to find the user's home directory. If we can't find it
comment|// return null so the JVM's default temporary directory is used
comment|// instead. This is probably /tmp or /var/tmp.
comment|//
name|String
name|userHome
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.home"
argument_list|)
decl_stmt|;
if|if
condition|(
name|userHome
operator|==
literal|null
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|userHome
argument_list|)
condition|)
block|{
name|userHome
operator|=
name|System
operator|.
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|userHome
operator|==
literal|null
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|userHome
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: cannot determine home directory"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: using system temporary directory instead"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|// Ensure the home directory exists. If it doesn't, try to make it.
comment|//
specifier|final
name|File
name|home
init|=
operator|new
name|File
argument_list|(
name|userHome
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|home
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|home
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: created "
operator|+
name|home
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: "
operator|+
name|home
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: using system temporary directory instead"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|// Use $HOME/.gerritcodereview/tmp for our temporary file area.
comment|//
specifier|final
name|File
name|gerrithome
init|=
operator|new
name|File
argument_list|(
name|home
argument_list|,
literal|".gerritcodereview"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gerrithome
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|gerrithome
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: cannot create "
operator|+
name|gerrithome
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"warning: using system temporary directory instead"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
return|return
name|gerrithome
operator|.
name|getCanonicalFile
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|gerrithome
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Check whether the process is running in Eclipse.    *    *<p>Unlike {@link #getDeveloperEclipseOut()}, this method checks the actual runtime stack, not    * the classpath.    *    * @return true if any thread has a stack frame in {@code org.eclipse.jdt}.    */
end_comment

begin_function
DECL|method|isRunningInEclipse ()
specifier|public
specifier|static
name|boolean
name|isRunningInEclipse
parameter_list|()
block|{
return|return
name|Thread
operator|.
name|getAllStackTraces
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|flatMap
argument_list|(
name|Arrays
operator|::
name|stream
argument_list|)
operator|.
name|anyMatch
argument_list|(
name|e
lambda|->
name|e
operator|.
name|getClassName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"org.eclipse.jdt."
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Locate the path of the {@code eclipse-out} directory in a source tree.    *    *<p>Unlike {@link #isRunningInEclipse()}, this method only inspects files relative to the    * classpath, not the runtime stack.    *    * @return local path of the {@code eclipse-out} directory in a source tree.    * @throws FileNotFoundException if the directory cannot be found.    */
end_comment

begin_function
DECL|method|getDeveloperEclipseOut ()
specifier|public
specifier|static
name|Path
name|getDeveloperEclipseOut
parameter_list|()
throws|throws
name|FileNotFoundException
block|{
return|return
name|resolveInSourceRoot
argument_list|(
literal|"eclipse-out"
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|isJdk9OrLater ()
specifier|public
specifier|static
name|boolean
name|isJdk9OrLater
parameter_list|()
block|{
return|return
name|Double
operator|.
name|parseDouble
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.class.version"
argument_list|)
argument_list|)
operator|>=
literal|53.0
return|;
block|}
end_function

begin_function
DECL|method|getJdkVersionPostJdk8 ()
specifier|public
specifier|static
name|String
name|getJdkVersionPostJdk8
parameter_list|()
block|{
comment|// 9.0.4 => 9
return|return
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.version"
argument_list|)
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|loadBuildProperties (Path propPath)
specifier|public
specifier|static
name|Properties
name|loadBuildProperties
parameter_list|(
name|Path
name|propPath
parameter_list|)
throws|throws
name|IOException
block|{
name|Properties
name|properties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
try|try
init|(
name|InputStream
name|in
init|=
name|Files
operator|.
name|newInputStream
argument_list|(
name|propPath
argument_list|)
init|)
block|{
name|properties
operator|.
name|load
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
name|e
parameter_list|)
block|{
comment|// Ignore; will be run from PATH, with a descriptive error if it fails.
block|}
return|return
name|properties
return|;
block|}
end_function

begin_decl_stmt
DECL|field|SOURCE_ROOT_RESOURCE
specifier|static
specifier|final
name|String
name|SOURCE_ROOT_RESOURCE
init|=
literal|"/com/google/gerrit/launcher/workspace-root.txt"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**    * Locate a path in the source tree.    *    * @return local path of the {@code name} directory in a source tree.    * @throws FileNotFoundException if the directory cannot be found.    */
end_comment

begin_function
DECL|method|resolveInSourceRoot (String name)
specifier|public
specifier|static
name|Path
name|resolveInSourceRoot
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
comment|// Find ourselves in the classpath, as a loose class file or jar.
name|Class
argument_list|<
name|GerritLauncher
argument_list|>
name|self
init|=
name|GerritLauncher
operator|.
name|class
decl_stmt|;
name|Path
name|dir
decl_stmt|;
name|String
name|sourceRoot
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"sourceRoot"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceRoot
operator|!=
literal|null
condition|)
block|{
name|dir
operator|=
name|Paths
operator|.
name|get
argument_list|(
name|sourceRoot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Files
operator|.
name|exists
argument_list|(
name|dir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"source root not found: "
operator|+
name|dir
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|URL
name|u
init|=
name|self
operator|.
name|getResource
argument_list|(
name|self
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".class"
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Cannot find class "
operator|+
name|self
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
literal|"jar"
operator|.
name|equals
argument_list|(
name|u
operator|.
name|getProtocol
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|p
init|=
name|u
operator|.
name|getPath
argument_list|()
decl_stmt|;
try|try
block|{
name|u
operator|=
operator|new
name|URL
argument_list|(
name|p
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|p
operator|.
name|indexOf
argument_list|(
literal|'!'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
name|FileNotFoundException
name|fnfe
init|=
operator|new
name|FileNotFoundException
argument_list|(
literal|"Not a valid jar file: "
operator|+
name|u
argument_list|)
decl_stmt|;
name|fnfe
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|fnfe
throw|;
block|}
block|}
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|u
operator|.
name|getProtocol
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Cannot extract path from "
operator|+
name|u
argument_list|)
throw|;
block|}
comment|// Pop up to the top-level source folder by looking for WORKSPACE.
name|dir
operator|=
name|Paths
operator|.
name|get
argument_list|(
name|u
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Files
operator|.
name|isRegularFile
argument_list|(
name|dir
operator|.
name|resolve
argument_list|(
literal|"WORKSPACE"
argument_list|)
argument_list|)
condition|)
block|{
name|Path
name|parent
init|=
name|dir
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Cannot find source root from "
operator|+
name|u
argument_list|)
throw|;
block|}
name|dir
operator|=
name|parent
expr_stmt|;
block|}
block|}
name|Path
name|ret
init|=
name|dir
operator|.
name|resolve
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Files
operator|.
name|exists
argument_list|(
name|ret
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|name
operator|+
literal|" not found in source root "
operator|+
name|dir
argument_list|)
throw|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
DECL|method|useDevClasspath ()
specifier|private
specifier|static
name|ClassLoader
name|useDevClasspath
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|out
init|=
name|getDeveloperEclipseOut
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|URL
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|dirs
operator|.
name|add
argument_list|(
name|out
operator|.
name|resolve
argument_list|(
literal|"classes"
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
expr_stmt|;
name|ClassLoader
name|cl
init|=
name|GerritLauncher
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
decl_stmt|;
if|if
condition|(
name|isJdk9OrLater
argument_list|()
condition|)
block|{
name|Path
name|rootPath
init|=
name|resolveInSourceRoot
argument_list|(
literal|"."
argument_list|)
operator|.
name|normalize
argument_list|()
decl_stmt|;
name|Properties
name|properties
init|=
name|loadBuildProperties
argument_list|(
name|rootPath
operator|.
name|resolve
argument_list|(
literal|".bazel_path"
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|outputBase
init|=
name|Paths
operator|.
name|get
argument_list|(
name|properties
operator|.
name|getProperty
argument_list|(
literal|"output_base"
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|runtimeClasspath
init|=
name|rootPath
operator|.
name|resolve
argument_list|(
literal|"bazel-bin/tools/eclipse/main_classpath_collect.runtime_classpath"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|f
range|:
name|Files
operator|.
name|readAllLines
argument_list|(
name|runtimeClasspath
argument_list|,
name|UTF_8
argument_list|)
control|)
block|{
name|URL
name|url
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
literal|"external"
argument_list|)
condition|)
block|{
name|url
operator|=
name|outputBase
operator|.
name|resolve
argument_list|(
name|f
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|toURL
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|url
operator|=
name|rootPath
operator|.
name|resolve
argument_list|(
name|f
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|toURL
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|includeJar
argument_list|(
name|url
argument_list|)
condition|)
block|{
name|dirs
operator|.
name|add
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|URL
name|u
range|:
operator|(
operator|(
name|URLClassLoader
operator|)
name|cl
operator|)
operator|.
name|getURLs
argument_list|()
control|)
block|{
if|if
condition|(
name|includeJar
argument_list|(
name|u
argument_list|)
condition|)
block|{
name|dirs
operator|.
name|add
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|URLClassLoader
operator|.
name|newInstance
argument_list|(
name|dirs
operator|.
name|toArray
argument_list|(
operator|new
name|URL
index|[
name|dirs
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|ClassLoader
operator|.
name|getSystemClassLoader
argument_list|()
operator|.
name|getParent
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|includeJar (URL u)
specifier|private
specifier|static
name|boolean
name|includeJar
parameter_list|(
name|URL
name|u
parameter_list|)
block|{
name|String
name|path
init|=
name|u
operator|.
name|getPath
argument_list|()
decl_stmt|;
return|return
name|path
operator|.
name|endsWith
argument_list|(
literal|".jar"
argument_list|)
operator|&&
operator|!
name|path
operator|.
name|endsWith
argument_list|(
literal|"-src.jar"
argument_list|)
operator|&&
operator|!
name|path
operator|.
name|contains
argument_list|(
literal|"/com/google/gerrit"
argument_list|)
return|;
block|}
end_function

begin_constructor
DECL|method|GerritLauncher ()
specifier|private
name|GerritLauncher
parameter_list|()
block|{}
end_constructor

unit|}
end_unit

